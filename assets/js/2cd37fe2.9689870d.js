"use strict";(self.webpackChunksdk_spec=self.webpackChunksdk_spec||[]).push([[535],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>N});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var p=n.createContext({}),m=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},s=function(e){var t=m(e.components);return n.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),k=m(a),N=l,d=k["".concat(p,".").concat(N)]||k[N]||u[N]||i;return a?n.createElement(d,r(r({ref:t},s),{},{components:a})):n.createElement(d,r({ref:t},s))}));function N(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,r=new Array(i);r[0]=k;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:l,r[1]=o;for(var m=2;m<i;m++)r[m]=a[m];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},5378:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>m});var n=a(7462),l=(a(7294),a(3905));const i={},r="Transaction-Related Interfaces",o={unversionedId:"Language-Independent Specification for Implementing the Topl SDK/Transaction API",id:"Language-Independent Specification for Implementing the Topl SDK/Transaction API",title:"Transaction-Related Interfaces",description:"BifrostClient",source:"@site/docs/Language-Independent Specification for Implementing the Topl SDK/Transaction API.md",sourceDirName:"Language-Independent Specification for Implementing the Topl SDK",slug:"/Language-Independent Specification for Implementing the Topl SDK/Transaction API",permalink:"/sdk-spec/docs/Language-Independent Specification for Implementing the Topl SDK/Transaction API",draft:!1,editUrl:"https://github.com/topl/sdk-spec/tree/main/packages/create-docusaurus/templates/shared/docs/Language-Independent Specification for Implementing the Topl SDK/Transaction API.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Tetra SDK High Level Design",permalink:"/sdk-spec/docs/Language-Independent Specification for Implementing the Topl SDK/Tetra SDK High Level Design"}},p={},m=[{value:"BifrostClient",id:"bifrostclient",level:2},{value:"Note",id:"note",level:3},{value:"Type Parameters",id:"type-parameters",level:3},{value:"Implemented By",id:"implemented-by",level:3},{value:"Methods/Functions",id:"methodsfunctions",level:3},{value:"Implementation Notes",id:"implementation-notes",level:3},{value:"MintingSupplyPolicy",id:"mintingsupplypolicy",level:2},{value:"Type Parameters",id:"type-parameters-1",level:3},{value:"Implemented By",id:"implemented-by-1",level:3},{value:"Methods/Functions",id:"methodsfunctions-1",level:3},{value:"Implementation Notes",id:"implementation-notes-1",level:3},{value:"StagedFutures",id:"stagedfutures",level:2},{value:"Type Parameters",id:"type-parameters-2",level:3},{value:"Implemented By",id:"implemented-by-2",level:3},{value:"Methods/Functions",id:"methodsfunctions-2",level:3},{value:"Implementation Notes",id:"implementation-notes-2",level:3},{value:"MintableToken",id:"mintabletoken",level:2},{value:"Implemented by",id:"implemented-by-3",level:3},{value:"Methods/Functions",id:"methodsfunctions-3",level:3},{value:"Implementation Notes",id:"implementation-notes-3",level:3},{value:"CommitType",id:"committype",level:2},{value:"Implemented by",id:"implemented-by-4",level:3},{value:"Methods/Functions",id:"methodsfunctions-4",level:3},{value:"Implementation Notes",id:"implementation-notes-4",level:3},{value:"Policy",id:"policy",level:2},{value:"Implemented by",id:"implemented-by-5",level:3},{value:"Methods/Functions",id:"methodsfunctions-5",level:3},{value:"Implementation Notes",id:"implementation-notes-5",level:3},{value:"MintingSupplyPolicyFactory",id:"mintingsupplypolicyfactory",level:2},{value:"Type Parameters",id:"type-parameters-3",level:3},{value:"Implements",id:"implements",level:3},{value:"Constructor",id:"constructor",level:3},{value:"Methods/Functions",id:"methodsfunctions-6",level:3},{value:"Implementation Notes",id:"implementation-notes-6",level:3},{value:"AssetBehavior",id:"assetbehavior",level:2},{value:"Constructor",id:"constructor-1",level:3},{value:"Methods/Functions",id:"methodsfunctions-7",level:3},{value:"Implementation Notes",id:"implementation-notes-7",level:3},{value:"AssetBehaviorFactory",id:"assetbehaviorfactory",level:2},{value:"Constructor",id:"constructor-2",level:3},{value:"Methods/Functions",id:"methodsfunctions-8",level:3},{value:"Implementation Notes",id:"implementation-notes-8",level:3},{value:"CommitTypeFactory",id:"committypefactory",level:2},{value:"Constructor",id:"constructor-3",level:3},{value:"Implements",id:"implements-1",level:3},{value:"Methods/Functions",id:"methodsfunctions-9",level:3},{value:"Implementation Notes",id:"implementation-notes-9",level:3},{value:"GroupPolicy",id:"grouppolicy",level:2},{value:"Constructor",id:"constructor-4",level:3},{value:"Implements",id:"implements-2",level:3},{value:"Methods/Functions",id:"methodsfunctions-10",level:3},{value:"Implementation Notes",id:"implementation-notes-10",level:3},{value:"SeriesPolicy",id:"seriespolicy",level:2},{value:"Constructor",id:"constructor-5",level:3},{value:"Implements",id:"implements-3",level:3},{value:"Methods/Functions",id:"methodsfunctions-11",level:3},{value:"Implementation Notes",id:"implementation-notes-11",level:3},{value:"ConstructorToken",id:"constructortoken",level:2},{value:"Constructor",id:"constructor-6",level:3},{value:"Implements",id:"implements-4",level:3},{value:"Methods/Functions",id:"methodsfunctions-12",level:3},{value:"Implementation Notes",id:"implementation-notes-12",level:3},{value:"AssetTokenV2",id:"assettokenv2",level:2},{value:"Constructor",id:"constructor-7",level:3},{value:"Implements",id:"implements-5",level:3},{value:"Methods/Functions",id:"methodsfunctions-13",level:3},{value:"Implementation Notes",id:"implementation-notes-13",level:3},{value:"GroupConstructor",id:"groupconstructor",level:2},{value:"Constructor",id:"constructor-8",level:3},{value:"Implements",id:"implements-6",level:3},{value:"Methods/Functions",id:"methodsfunctions-14",level:3},{value:"Implementation Notes",id:"implementation-notes-14",level:3},{value:"SeriesConstructor",id:"seriesconstructor",level:2},{value:"Constructor",id:"constructor-9",level:3},{value:"Implements",id:"implements-7",level:3},{value:"Methods/Functions",id:"methodsfunctions-15",level:3},{value:"Implementation Notes",id:"implementation-notes-15",level:3},{value:"AssetConstructor",id:"assetconstructor",level:2},{value:"Constructor",id:"constructor-10",level:3},{value:"Implements",id:"implements-8",level:3},{value:"Methods/Functions",id:"methodsfunctions-16",level:3},{value:"Implementation Notes",id:"implementation-notes-16",level:3},{value:"Schedule",id:"schedule",level:2},{value:"Type Parameters",id:"type-parameters-4",level:3},{value:"Constructor",id:"constructor-11",level:3},{value:"Implements",id:"implements-9",level:3},{value:"Methods/Functions",id:"methodsfunctions-17",level:3},{value:"Implementation Notes",id:"implementation-notes-17",level:3},{value:"TransactionUnprovenInput",id:"transactionunproveninput",level:2},{value:"Constructor",id:"constructor-12",level:3},{value:"Implements",id:"implements-10",level:3},{value:"Methods/Functions",id:"methodsfunctions-18",level:3},{value:"Implementation Notes",id:"implementation-notes-18",level:3},{value:"TransactionInput",id:"transactioninput",level:2},{value:"Constructor",id:"constructor-13",level:3},{value:"Implements",id:"implements-11",level:3},{value:"Methods/Functions",id:"methodsfunctions-19",level:3},{value:"Implementation Notes",id:"implementation-notes-19",level:3},{value:"TransactionOutput",id:"transactionoutput",level:2},{value:"Type Parameters",id:"type-parameters-5",level:3},{value:"Constructor",id:"constructor-14",level:3},{value:"Implements",id:"implements-12",level:3},{value:"Methods/Functions",id:"methodsfunctions-20",level:3},{value:"Implementation Notes",id:"implementation-notes-20",level:3},{value:"Transput",id:"transput",level:2},{value:"Constructor",id:"constructor-15",level:3},{value:"Implements",id:"implements-13",level:3},{value:"Methods/Functions",id:"methodsfunctions-21",level:3},{value:"Implementation Notes",id:"implementation-notes-21",level:3},{value:"UnprovenTransaction",id:"unproventransaction",level:2},{value:"Type Parameters",id:"type-parameters-6",level:3},{value:"Constructor",id:"constructor-16",level:3},{value:"Implements",id:"implements-14",level:3},{value:"Methods/Functions",id:"methodsfunctions-22",level:3},{value:"Implementation Notes",id:"implementation-notes-22",level:3},{value:"Transaction",id:"transaction",level:2},{value:"Type Parameters",id:"type-parameters-7",level:3},{value:"Constructor",id:"constructor-17",level:3},{value:"Implements",id:"implements-15",level:3},{value:"Methods/Functions",id:"methodsfunctions-23",level:3},{value:"Implementation Notes",id:"implementation-notes-23",level:3},{value:"BifrostTetraClient",id:"bifrosttetraclient",level:2},{value:"Type Parameters",id:"type-parameters-8",level:3},{value:"Implements",id:"implements-16",level:3},{value:"Constructor",id:"constructor-18",level:3},{value:"Methods/Functions",id:"methodsfunctions-24",level:3},{value:"Implementation Notes",id:"implementation-notes-24",level:3}],s={toc:m};function u(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"transaction-related-interfaces"},"Transaction-Related Interfaces"),(0,l.kt)("h2",{id:"bifrostclient"},"BifrostClient"),(0,l.kt)("p",null,"All classes that can be used a client to interact with Topl bifrost nodes implement this interface."),(0,l.kt)("h3",{id:"note"},"Note"),(0,l.kt)("p",null,"It is possible and likely that public methods/functions will be added to this interface in the future. Implementations of this interface should not make any assumptions about members not being added to this interface."),(0,l.kt)("h3",{id:"type-parameters"},"Type Parameters"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"implemented-by"},"Implemented By"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"#bifrosttetraclient"},"BifrostTetraClient")),(0,l.kt)("h3",{id:"methodsfunctions"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"mintingsupplypolicy"},"MintingSupplyPolicy"),(0,l.kt)("p",null,"This interface is implemented by classes that can be used to define the supply policy for minting an asset within a series or how many series  may be tied to a group."),(0,l.kt)("h3",{id:"type-parameters-1"},"Type Parameters"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"implemented-by-1"},"Implemented By"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public implementations")),(0,l.kt)("h3",{id:"methodsfunctions-1"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-1"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"stagedfutures"},"StagedFutures"),(0,l.kt)("p",null,"Methods that submit transactions to the blockchain return an object that implements this interface. This interface allows the caller to get a future for the submission of the transaction and for the successfully settled transaction."),(0,l.kt)("h3",{id:"type-parameters-2"},"Type Parameters"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"implemented-by-2"},"Implemented By"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public implementations")),(0,l.kt)("h3",{id:"methodsfunctions-2"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"settled")," \\\nReturns a future for the outcome of transaction validation, consensus and the transaction being settled.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"confidenceFactor")," \\\nThe likelihood of the block containing the transaction to be reorged.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Double"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: 1 - 10",(0,l.kt)("sup",null,"-9")))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nFuture[",(0,l.kt)("a",{parentName:"li",href:"#result"},"Result"),"]",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S ="),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"All of the failures recognized by the submission future "))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"submission")," \\\nReturns a future for the result of submitting a transaction to a blockchain.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nFuture[",(0,l.kt)("a",{parentName:"li",href:"#result"},"Result"),"]",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = Type TBD"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Insufficient private keys available to create a valid proof")))))))),(0,l.kt)("h3",{id:"implementation-notes-2"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"mintabletoken"},"MintableToken"),(0,l.kt)("p",null,"This interface is implemented by objects that represent a mintable token."),(0,l.kt)("h3",{id:"implemented-by-3"},"Implemented by"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"#groupconstructor"},"GroupConstructor"),", ",(0,l.kt)("a",{parentName:"p",href:"#seriesconstructor"},"SeriesConstructor"),", ",(0,l.kt)("a",{parentName:"p",href:"#assetconstructor"},"AssetConstructor")),(0,l.kt)("h3",{id:"methodsfunctions-3"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-3"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"committype"},"CommitType"),(0,l.kt)("p",null,"This interface is implemented by objects that represent the commitment scheme for a Series Policy."),(0,l.kt)("h3",{id:"implemented-by-4"},"Implemented by"),(0,l.kt)("p",null,"The return values of ",(0,l.kt)("a",{parentName:"p",href:"#committypefactory"},"CommitTypeFactory")),(0,l.kt)("h3",{id:"methodsfunctions-4"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-4"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"policy"},"Policy"),(0,l.kt)("p",null,"This interface is implemented by objects that represent an off-chain Group or Series Policy."),(0,l.kt)("h3",{id:"implemented-by-5"},"Implemented by"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"#grouppolicy"},"GroupPolicy"),", ",(0,l.kt)("a",{parentName:"p",href:"#seriespolicy"},"SeriesPolicy")),(0,l.kt)("h3",{id:"methodsfunctions-5"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getId")," \\\nReturns the ID associated with this policy. This should be identifiable via the fields in the implementing classes.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = Byte","[32]"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getEvidence")," \\\nReturns the evidence for this policy.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = Byte","[32]"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setRegistrationUtxo")," \\\nSets the arbitrary box ID to bind to this policy. This value provides uniqueness that can be checked by the protocol to know if this group policy has been generated previously. This box ID must be unique for policy registrations across transactions.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"boxId")," \\\nThe Box ID",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L17"},"Box.Id")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nAn implementation specific value denoting a succesful update is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("h3",{id:"implementation-notes-5"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h1",{id:"transaction-related-classes"},"Transaction-Related Classes"),(0,l.kt)("h2",{id:"mintingsupplypolicyfactory"},"MintingSupplyPolicyFactory"),(0,l.kt)("p",null,"A utility class to provide token supply policies."),(0,l.kt)("h3",{id:"type-parameters-3"},"Type Parameters"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"implements"},"Implements"),(0,l.kt)("p",null,"The return values of all functions return an implementation of ",(0,l.kt)("a",{parentName:"p",href:"#mintingsupplypolicy"},"MintingSupplyPolicy")),(0,l.kt)("h3",{id:"constructor"},"Constructor"),(0,l.kt)("p",null,"The construct is private or there is none."),(0,l.kt)("h3",{id:"methodsfunctions-6"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"static cappedSupply")," \\\nGet an object to specify a supply policy that caps the total supply of tokens to a given value.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"maxQuantity")," \\\nThe maximum quantity of a token that the returned policy will allow to exist."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\n",(0,l.kt)("a",{parentName:"li",href:"#mintingsupplypolicy"},"MintingSupplyPolicy")," \\\nAn object that indicates that the total supply of the token is capped to the specified value. There will never be more than the max quantity."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"static fixedSupply")," \\\nGet an object to specify a supply policy that fixes the total supply of a token to the quantity that was produced when it was initially minted.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\n",(0,l.kt)("a",{parentName:"li",href:"#mintingsupplypolicy"},"MintingSupplyPolicy")," \\\nAn object that indicates that the supply of a token is fixed at the time of its first (and only) minting.\nThere will never be any more."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"static unlimitedSupply")," \\\nGet an object to specify a minting supply policy that allows additional quantities of a token to be minted without limit.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\n",(0,l.kt)("a",{parentName:"li",href:"#mintingsupplypolicy"},"MintingSupplyPolicy")," \\\nAn object that indicates that the supply of a a token is unlimited.")))),(0,l.kt)("h3",{id:"implementation-notes-6"},"Implementation Notes"),(0,l.kt)("p",null,"It is possible that additional methods will be added to create KeyVault objects that correspond to different implementations of the KeyVault interfaces."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"assetbehavior"},"AssetBehavior"),(0,l.kt)("p",null,"This interface is implemented by objects that represent on-chain transfer behaviors; used in a supply policy."),(0,l.kt)("h3",{id:"constructor-1"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"interGroupFungible")," \\\nShould the protocol consider this series fungible with other like tokens that share this group id? (may go between series)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Boolean"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"interSeriesFungible")," \\\nShould the protocol consider this series fungible with other like tokens that share this series id? (may go between groups)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Boolean"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantityIncrease"),' \\\nShould the protocol allow the "quantity" field in an asset token of this type to increase?',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Boolean"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantityDecrease"),' \\\nShould the protocol allow the "quantity" field in an asset token of this type to decrease?',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Boolean"),(0,l.kt)("li",{parentName:"ul"},"Optional: no")))),(0,l.kt)("h3",{id:"methodsfunctions-7"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-7"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"assetbehaviorfactory"},"AssetBehaviorFactory"),(0,l.kt)("p",null,"A utility class to provide objects which denote on-chain transfer behaviors"),(0,l.kt)("h3",{id:"constructor-2"},"Constructor"),(0,l.kt)("p",null,"The construct is private or there is none."),(0,l.kt)("h3",{id:"methodsfunctions-8"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"NFT")," \\\nReturns an object denoting non interGroupFungible, non interSeriesFungible, no quantityIncrease and no quanitityDecrease (FFFF) token behavior",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#assetbehavior"},"AssetBehavior")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f The other functions (which create the other combinations of behavior) will go here\nThe names of the functions are still undecided"),(0,l.kt)("ul",{parentName:"blockquote"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"FullyFungible")," \\\nReturns an object denoting TTTT token behavior",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#assetbehavior"},"AssetBehavior")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))))),(0,l.kt)("h3",{id:"implementation-notes-8"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"committypefactory"},"CommitTypeFactory"),(0,l.kt)("p",null,"A utility class to provide supply policy commitment types."),(0,l.kt)("h3",{id:"constructor-3"},"Constructor"),(0,l.kt)("p",null,"The construct is private or there is none."),(0,l.kt)("h3",{id:"implements-1"},"Implements"),(0,l.kt)("p",null,"The return values of all functions return an implementation of ",(0,l.kt)("a",{parentName:"p",href:"#committype"},"CommitType")),(0,l.kt)("h3",{id:"methodsfunctions-9"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"hash")," \\\nReturns an object that represents a Hash commitment type.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"hashAlgo")," \\\nType of hashing algorithm to use",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: MessageDigester"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: TBD"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#committype"},"CommitType")," \\\nAn object that represents a Hash commitment type"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"merkleTree")," \\\nReturns an object that represents a MerkleTree commitment type.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"hashAlgo")," \\\nType of hashing algorithm to use",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: MessageDigester"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: TBD"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"blockSize")," \\\nBlock size to use in Bytes.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt16"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: 1024"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#committype"},"CommitType")," \\\nAn object that represents a MerkleTree commitment type"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"rsaAccumulator")," \\\nReturns an object that represents an RSA Accumulator commitment type.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"bitSize")," \\\nBit size to use.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt32"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: 2048"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#committype"},"CommitType")," \\\nAn object that represents an RSA Accumulator commitment type"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("h3",{id:"implementation-notes-9"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"grouppolicy"},"GroupPolicy"),(0,l.kt)("p",null,"Objects of this class represents an off-chain Group Policy."),(0,l.kt)("h3",{id:"constructor-4"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"label")," \\\nThe label for defining the name of a group, constraints?",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: String"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fixedSeriesPolicy")," \\\nRestrict the Group to have only a single type of series token that is applicable to this Group",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[32]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"supplyControlForSeries"),' \\\nDefines the expected on-chain behavior for how many Series may be "assigned" to a Group',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#mintingsupplypolicy"},"MintingSupplyPolicy")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mintConditionsForSeries")," \\\nDefines the proposition that must be stamped on a Group Constructor (is this needed?)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/proposition.proto#L9"},"Proposition")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"registrationUtxo")," \\\nAn arbitrary box ID to bind to this policy. This value provides uniqueness that can be checked by the protocol to know if this group policy has been generated previously. This box ID must be unique for policy registrations across transactions.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L17"},"Box.Id")),(0,l.kt)("li",{parentName:"ul"},"Optional: yes")))),(0,l.kt)("h3",{id:"implements-2"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"#policy"},"Policy")),(0,l.kt)("h3",{id:"methodsfunctions-10"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-10"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"seriespolicy"},"SeriesPolicy"),(0,l.kt)("p",null,"Objects of this class represents an off-chain Series Policy."),(0,l.kt)("h3",{id:"constructor-5"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"label")," \\\nThe label for defining the name of a series, constraints?",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: String"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"onChainTransferBehaviors")," \\\nDefines the type of token within the TAM2 scheme",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#assetbehavior"},"AssetBehavior")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"supplyControlForAssets"),' \\\nDefines the expected on-chain behavior for how many Asset Tokens may be "produced" within a Series',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#mintingsupplypolicy"},"MintingSupplyPolicy")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mintControlForAssets")," \\\nDefines the proposition that must be stamped on a Series Constructor (is this needed?)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Proposition"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"registrationUtxo")," \\\nAn arbitrary box ID to bind to this policy. This value provides uniqueness that can be checked by the protocol to know if this series policy has been generated previously. This box ID must be unique for policy registrations across transactions.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L17"},"Box.Id")),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"commitScheme")," \\\nThis value defines the expected type of committment that users should employee when verifying data on asset tokens within this series. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#committype"},"CommitType")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"metadataScheme")," \\\nA (possibly mixin based) metadata definition that allows for application level data constructs. Possible schemes that this value could denote include HasUnit, HasDecimals, MimePointer, LookupKey, Labeled, Unstructured, Versionable, and more.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: TBD"),(0,l.kt)("li",{parentName:"ul"},"Optional: no")))),(0,l.kt)("h3",{id:"implements-3"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"#policy"},"Policy")),(0,l.kt)("h3",{id:"methodsfunctions-11"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-11"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"constructortoken"},"ConstructorToken"),(0,l.kt)("p",null,"An object representing a Group or Series Constructor Token."),(0,l.kt)("h3",{id:"constructor-6"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantity")," \\\nThe quantity of this Constructor token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt128"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"policyEvidence")," \\\nThe policy evidence for this constructor token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[32]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes")))),(0,l.kt)("h3",{id:"implements-4"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"methodsfunctions-12"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setQuantity")," \\\nSet the quantity.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantity")," \\\nThe quantity of the constructor token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt128"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nAn implementation specific value denoting a succesful update is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getQuantity")," \\\nReturn the quantity.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = UInt128 or <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nIf quantity is not set, an implementation specific value denoting nothing is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setPolicyEvidence")," \\\nSet the policy evidence of this constructor token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"policyEvidence")," \\\nThe policy evidence",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[32]"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nAn implementation specific value denoting a succesful update is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getPolicyEvidence")," \\\nReturn the policy evidence of this constructor token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = Byte","[32]"," or <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nIf policy evidence is not set, an implementation specific value denoting nothing is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("h3",{id:"implementation-notes-12"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"assettokenv2"},"AssetTokenV2"),(0,l.kt)("p",null,"An object representing a V2 Asset Token."),(0,l.kt)("h3",{id:"constructor-7"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"label")," \\\nThe asset label of this token. The label encompasses the IDs of the group and series it belongs to",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: String"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantity")," \\\nThe quantity of this token",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt128"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"commitRoot")," \\\nThe commitment root for this token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[127]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"metadata")," \\\nOptional metadata associated with this token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[127]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes")))),(0,l.kt)("h3",{id:"implements-5"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"methodsfunctions-13"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setQuantity")," \\\nSet the quantity.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantity")," \\\nThe quantity of the constructor token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt128"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nAn implementation specific value denoting a succesful update is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getQuantity")," \\\nReturn the quantity.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = UInt128 or <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nIf quantity is not set, an implementation specific value denoting nothing is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setCommitRoot")," \\\nSet the commit root of this asset token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"commitRoot")," \\\nThe commit root",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[127]"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nAn implementation specific value denoting a succesful update is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getCommitRoot")," \\\nReturn the commit root of this asset token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = Byte","[127]"," or <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nIf commit root is not yet set, an implementation specific value denoting nothing is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("h3",{id:"implementation-notes-13"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"groupconstructor"},"GroupConstructor"),(0,l.kt)("p",null,"An instance of this class represents a mintable Group Constructor Token."),(0,l.kt)("h3",{id:"constructor-8"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"policy")," \\\nThe group policy tied to this GroupConstructor token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#grouppolicy"},"GroupPolicy")),(0,l.kt)("li",{parentName:"ul"},"Optional: no")))),(0,l.kt)("h3",{id:"implements-6"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"#mintabletoken"},"MintableToken")),(0,l.kt)("h3",{id:"methodsfunctions-14"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-14"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"seriesconstructor"},"SeriesConstructor"),(0,l.kt)("p",null,"An instance of this class represents a mintable Series Constructor Token."),(0,l.kt)("h3",{id:"constructor-9"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"policy")," \\\nThe series policy tied to this SeriesConstructor token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#seriespolicy"},"SeriesPolicy")),(0,l.kt)("li",{parentName:"ul"},"Optional: no")))),(0,l.kt)("h3",{id:"implements-7"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"#mintabletoken"},"MintableToken")),(0,l.kt)("h3",{id:"methodsfunctions-15"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-15"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"assetconstructor"},"AssetConstructor"),(0,l.kt)("p",null,"An instance of this class represents a mintable Asset Constructor Token."),(0,l.kt)("h3",{id:"constructor-10"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"groupPolicy")," \\\nThe group policy tied to this AssetConstructor token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#grouppolicy"},"GroupPolicy")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"seriesPolicy")," \\\nThe series policy tied to this AssetConstructor token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#seriespolicy"},"SeriesPolicy")),(0,l.kt)("li",{parentName:"ul"},"Optional: no")))),(0,l.kt)("h3",{id:"implements-8"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"#mintabletoken"},"MintableToken")),(0,l.kt)("h3",{id:"methodsfunctions-16"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-16"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"schedule"},"Schedule"),(0,l.kt)("p",null,"Represents constraints on when a Transaction can be included in the blockchain. An instance of this class reflects ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/transaction.proto#L42"},"Transaction.Schedule"),"."),(0,l.kt)("h3",{id:"type-parameters-4"},"Type Parameters"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"constructor-11"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"creationTime")," \\\nThe time that the application claims the transaction was created. This is translated to a UNIX timestamp and used to set the Schedule object's creation field.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: The current time"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"earliestTime")," \\\nThe earliest time that the transaction is eligible to be included in a block. This will be converted to a slot number and used to set the Schedule object's minimumSlot field. Note that this can be in the future. However, if it is too far in the future, then nodes may evict it from their mempool.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: Beginning of time "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"latestTime")," \\\nThe latest time that the transaction is eligible to be included in a block. This will be converted to a slot number and used to set the Schedule object's maximumSlot field.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: 5 minutes into the future")))),(0,l.kt)("h3",{id:"implements-9"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"methodsfunctions-17"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getCreation")," \\\nA UNIX timestamp (ms) of the transaction's original creation.  User-defined with no impact on the protocol.  Must be positive.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = UInt64"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getMinimumSlot")," \\\nThe minimum slot number of the block containing the transaction",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = UInt64"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getMaximumSlot")," \\\nThe maximum slot number of the block constaing this transaction.  Must be greater than ",(0,l.kt)("inlineCode",{parentName:"li"},"minimumSlot"),".",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = UInt64"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("h3",{id:"implementation-notes-17"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"transactionunproveninput"},"TransactionUnprovenInput"),(0,l.kt)("p",null,"An instance of this class augments ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/transaction.proto#L22"},"Transaction.Input")," without Proof."),(0,l.kt)("h3",{id:"constructor-12"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"box")," \\\nThe box that this input is associated to.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Augmented version of ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L10"},"Box")," "),(0,l.kt)("li",{parentName:"ul"},"Optional: no")))),(0,l.kt)("h3",{id:"implements-10"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"methodsfunctions-18"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getBoxId")," \\\nReturns the boxId associated with this TransactionUnprovenInput.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L17"},"Box.Id")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getProposition")," \\\nReturns the proposition associated with this TransactionUnprovenInput.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/proposition.proto#L9"},"Proposition")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"\ud83d\udea7 Note\nAssetTokenV2 and ConstructorToken will be reflected as a BoxValue in protobuff in the near future. ")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getValue")," \\\nReturns the value associated with this TransactionUnprovenInput.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L24"},"BoxValue")," | ",(0,l.kt)("a",{parentName:"li",href:"#assettokenv2"},"AssetTokenV2")," | ",(0,l.kt)("a",{parentName:"li",href:"#constructortoken"},"ConstructorToken")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getAccount")," \\\nReturns the account from where the box that is associated with this input is from.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = Account"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("h3",{id:"implementation-notes-18"},"Implementation Notes"),(0,l.kt)("p",null,"In general, the Proposition and Value will be obtainable in the local wallet via the supplied ",(0,l.kt)("inlineCode",{parentName:"p"},"boxId")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"transactioninput"},"TransactionInput"),(0,l.kt)("p",null,"An instance of this class reflects ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/transaction.proto#L22"},"Transaction.Input"),"."),(0,l.kt)("h3",{id:"constructor-13"},"Constructor"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"\ud83d\udea7 Note\nAssetTokenV2 and ConstructorToken will be reflected as a BoxValue in protobuff in the near future. ")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"boxId")," \\\nThe ID of the box that this input is associated to.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L17"},"Box.Id")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"proposition")," \\\nThe Proposition associated with this input.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/proposition.proto#L9"},"Proposition")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"proof")," \\\nThe Proof associated with this input to satisfy the proposition",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/proof.proto#L8"},"Proof")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," \\\nThe value associated with this input.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L24"},"BoxValue")," | ",(0,l.kt)("a",{parentName:"li",href:"#assettokenv2"},"AssetTokenV2")," | ",(0,l.kt)("a",{parentName:"li",href:"#constructortoken"},"ConstructorToken")),(0,l.kt)("li",{parentName:"ul"},"Optional: no")))),(0,l.kt)("h3",{id:"implements-11"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"methodsfunctions-19"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getBoxId")," \\\nReturns the boxId associated with this TransactionInput.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L17"},"Box.Id")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getProposition")," \\\nReturns the Proposition associated with this TransactionInput.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/proposition.proto#L9"},"Proposition")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getProof")," \\\nReturns the Proof associated with this TransactionInput to satisfy the proposition.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/proof.proto#L8"},"Proof")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"\ud83d\udea7 Note\nAssetTokenV2 and ConstructorToken will be reflected as a BoxValue in protobuff in the near future. ")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getValue")," \\\nReturns the value associated with this TransactionInput.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L24"},"BoxValue")," | ",(0,l.kt)("a",{parentName:"li",href:"#assettokenv2"},"AssetTokenV2")," | ",(0,l.kt)("a",{parentName:"li",href:"#constructortoken"},"ConstructorToken")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("h3",{id:"implementation-notes-19"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"transactionoutput"},"TransactionOutput"),(0,l.kt)("p",null,"An object representing a transaction output. This reflect the Tetra version of ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/transaction.proto#L33"},"Transaction.Output")),(0,l.kt)("h3",{id:"type-parameters-5"},"Type Parameters"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"constructor-14"},"Constructor"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"\ud83d\udea7 Note\nAssetTokenV2 and ConstructorToken will be reflected as a ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L24"},"BoxValue")," in protobuff in the near future."),(0,l.kt)("ul",{parentName:"blockquote"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," \\\nThe address of this output.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/address.proto#L10"},"Address")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," \\\nAn object representing the value contained in this output.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Augmented ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L24"},"BoxValue")," | ",(0,l.kt)("a",{parentName:"li",href:"#constructortoken"},"ConstructorToken")," | ",(0,l.kt)("a",{parentName:"li",href:"#assettokenv2"},"AssetTokenV2")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"minting")," \\\nAn optional object representing the policy which determines if minting is allowed. If not provided, the output is not considered a minting output",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#mintabletoken"},"MintableToken")),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))))),(0,l.kt)("h3",{id:"implements-12"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"methodsfunctions-20"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setQuantity")," \\\nUpdate the quantity within ",(0,l.kt)("inlineCode",{parentName:"li"},"value"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantity")," \\\nThe new quantity of the output's value."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value denotes a successful update"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getAddress")," \\\nThe address of this output.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/address.proto#L10"},"Address")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getValue")," \\\nAn object representing the value contained in this output.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = Augmented ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/box.proto#L24"},"BoxValue")," | ",(0,l.kt)("a",{parentName:"li",href:"#constructortoken"},"ConstructorToken")," | ",(0,l.kt)("a",{parentName:"li",href:"#assettokenv2"},"AssetTokenV2")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getMinting")," \\\nAn optional object representing the policy which determines if minting is allowed. If not provided, the output is not considered a minting output",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#mintabletoken"},"MintableToken")," or <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nThe mintable token if output is a minting output. Otherwise an implementation specific value denoting nothing is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("h3",{id:"implementation-notes-20"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"transput"},"Transput"),(0,l.kt)("p",null,"An instance of this class contains the required ",(0,l.kt)("a",{parentName:"p",href:"#transactionunproveninput"},"TransactionUnprovenInput"),"s and at most one ",(0,l.kt)("a",{parentName:"p",href:"#transactionoutput"},"TransactionOutput")," needed to satisfy the desired quantity of a transaction input."),(0,l.kt)("h3",{id:"constructor-15"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"requiredQuantity")," \\\nThe required quantity of ",(0,l.kt)("inlineCode",{parentName:"li"},"assetIdentifier")," needed",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt128"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: If not supplied, the quantity will be all unspent ",(0,l.kt)("inlineCode",{parentName:"li"},"assetIdentifier")," tokens in ",(0,l.kt)("inlineCode",{parentName:"li"},"account")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"assetIdentifier")," \\\nAn identifier which denotes a type of asset (an AssetV2 assetLabel, an AssetV1 assetCode, LVL type, TOPL type, etc) ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: String"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"account")," \\\nThe Account from where the input will be obtained. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Account"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},'Default: The account entity at path "0/0"'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"changeAddress")," \\\nThe address where any excess funds from the input will go. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Address"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: The next available address in ",(0,l.kt)("inlineCode",{parentName:"li"},"account"))))),(0,l.kt)("h3",{id:"implements-13"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"methodsfunctions-21"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getSpendInputs")," \\\nReturns the Inputs required to satisfy the quantity required and to move boxes that are not required to satisfy quantity in order to prevent address re-use. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = Array of ",(0,l.kt)("a",{parentName:"li",href:"#transactionunproveninput"},"TransactionUnprovenInput")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"getChangeOutput")," \\\nIf the quantity within the inputs exceed the ",(0,l.kt)("inlineCode",{parentName:"li"},"requiredQuantity"),", returns the output to contain this excess change. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," \\\n",(0,l.kt)("em",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#transactionoutput"},"TransactionOutput")," or <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> \\\nThe change output if change exists. Otherwise an implementation specific value denoting nothing is returned."),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("h3",{id:"implementation-notes-21"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"unproventransaction"},"UnprovenTransaction"),(0,l.kt)("p",null,"An instance of this class reflects a version of ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/transaction.proto#L11"},"Transaction")," where the inputs do not have proofs."),(0,l.kt)("h3",{id:"type-parameters-6"},"Type Parameters"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"constructor-16"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"inputs")," \\\nThe inputs of this transaction.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Array of ",(0,l.kt)("a",{parentName:"li",href:"#transactionunproveninput"},"TransactionUnprovenInput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"outputs")," \\\nThe outputs of this transaction.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Array of ",(0,l.kt)("a",{parentName:"li",href:"#transactionoutput"},"TransactionOutput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"schedule")," \\\nAn object representing the constraints on when a Transaction can be included in the blockchain",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#schedule"},"Schedule")),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"data")," \\\nData to be associated with this transaction. Has no effect on the protocol level.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[15000]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes")))),(0,l.kt)("h3",{id:"implements-14"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"methodsfunctions-22"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-22"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"transaction"},"Transaction"),(0,l.kt)("p",null,"An instance of this class reflects ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/Topl/protobuf-specs/blob/main/protobuf/models/transaction.proto#L11"},"Transaction"),"."),(0,l.kt)("h3",{id:"type-parameters-7"},"Type Parameters"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"constructor-17"},"Constructor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"inputs")," \\\nThe inputs of this transaction.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Array of ",(0,l.kt)("a",{parentName:"li",href:"#transactionuninput"},"TransactionInput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"outputs")," \\\nThe outputs of this transaction.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Array of ",(0,l.kt)("a",{parentName:"li",href:"#transactionoutput"},"TransactionOutput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"schedule")," \\\nAn object representing the constraints on when a Transaction can be included in the blockchain",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#schedule"},"Schedule")),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"data")," \\\nData to be associated with this transaction. Has no effect on the protocol level.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[15000]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes")))),(0,l.kt)("h3",{id:"implements-15"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"methodsfunctions-23"},"Methods/Functions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"No public methods/functions")),(0,l.kt)("h3",{id:"implementation-notes-23"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"bifrosttetraclient"},"BifrostTetraClient"),(0,l.kt)("h3",{id:"type-parameters-8"},"Type Parameters"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h3",{id:"implements-16"},"Implements"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"#bifrostclient"},"BifrostClient")),(0,l.kt)("h3",{id:"constructor-18"},"Constructor"),(0,l.kt)("p",null,"The constructor is private or there is none."),(0,l.kt)("h3",{id:"methodsfunctions-24"},"Methods/Functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"input")," \\\nReturns a ",(0,l.kt)("a",{parentName:"p",href:"#transput"},"Transput")," based on the requirements"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"requiredQuantity")," \\\nThe required quantity that this input needs",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt128"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"assetIdentifier")," \\\nAn identifier which denotes a type of asset (an AssetV2 assetLabel, an AssetV1 assetCode, LVL type, TOPL type, etc) ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: String"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"account")," \\\nThe Account from where the input will be obtained. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Account"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},'Default: The account entity at path "0/0"'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"changeAddress")," \\\nThe address where any excess funds from the input will go. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Address"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: The next available address in ",(0,l.kt)("inlineCode",{parentName:"li"},"account")))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#transput"},"Transput")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"A token defined by ",(0,l.kt)("inlineCode",{parentName:"li"},"assetIdentifier")," does not exist"),(0,l.kt)("li",{parentName:"ul"},"The quantity of ",(0,l.kt)("inlineCode",{parentName:"li"},"assetIdentifier")," does not exist in ",(0,l.kt)("inlineCode",{parentName:"li"},"account")," "),(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"output")," \\\nReturns a ",(0,l.kt)("a",{parentName:"p",href:"#transactionoutput"},"TransactionOutput"),". Not valid for EmptyBoxValue."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"account")," \\\nThe Account for where the output will reside. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Account"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"assetIdentifier")," \\\nAn identifier which denotes a type of asset (an AssetV2 assetLabel, an AssetV1 assetCode, LVL type, TOPL type, etc) ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: String"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantity")," \\\nThe quantity of the output's value.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt128"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"metadata")," \\\nOptional metadata to include with the minted asset token. "," Only valid for V1 and V2 asset tokens.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[127]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#transactionoutput"},"TransactionOutput")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantity")," is invalid"),(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"mintingOutput")," \\\nReturns a minting ",(0,l.kt)("a",{parentName:"p",href:"#transactionoutput"},"TransactionOutput"),". Not valid for Topls, Lvls, and EmptyBoxValue"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"account")," \\\nThe Account for where the output will reside. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Account"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"assetIdentifier")," \\\nAn identifier which denotes a type of asset (an AssetV2 assetLabel, an AssetV1 assetCode, etc) ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: String"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantity")," \\\nThe quantity of the output's value.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt128"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"minting")," \\\nThe mintable token.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#mintabletoken"},"MintableToken")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"metadata")," \\\nOptional metadata to include with the minted asset token. "," Only valid for V1 and V2 asset tokens.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[127]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#transactionoutput"},"TransactionOutput")),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"quantity")," is invalid"),(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"registerConstructor")," \\\nSubmits a ",(0,l.kt)("a",{parentName:"p",href:"#transaction"},"Transaction")," for registering a Group or Series Constructor Token"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fee")," \\\nThe inputs and change output relating to this transaction's fee.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#transput"},"Transput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"data")," \\\nData to be associated with this transaction. Has no effect on the protocol level.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[15000]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"policy")," \\\nThe policy that we are registering.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#policy"},"Policy")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mintingOutput")," \\\nThe output containing the minted constructor tokens",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#transactionoutput"},"TransactionOutput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"creationTime")," \\\nThe time that the application claims the transaction was created. This is translated to a UNIX timestamp and used to set the Schedule object's creation field.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: The current time"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"earliestTime")," \\\nThe earliest time that this transaction is eligible to be included in a block. This will be converted to a slot number and used to set the Schedule object's minimumSlot field. Note that this can be in the future. However, if it is too far in the future, then nodes may evict it from their mempool.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: Beginning of time "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"latestTime")," \\\nThe latest time that this transaction is eligible to be included in a block. This will be converted to a slot number and used to set the Schedule object's maximumSlot field.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: 5 minutes into the future"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#stagedfutures"},"StagedFutures")," for the submitted transaction"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Transaction is not valid"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mintingOutput")," does not specify a quantity"),(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"registerAssetType")," \\\nSubmit ",(0,l.kt)("a",{parentName:"p",href:"#transaction"},"Transaction"),"s for minting a new V2 Asset Token with newly registered Group and Series Policies."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Parameters")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fee")," \\\nThe inputs and change output relating to this transaction's fee.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#transput"},"Transput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"data")," \\\nData to be associated with the underlying transactions. Has no effect on the protocol level.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[15000]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"assetAlias")," \\\nA human readable label to associate with the newly minted Asset Token. This will also be the default value if ",(0,l.kt)("inlineCode",{parentName:"li"},"groupLabel")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"seriesLabel")," is not provided",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: String"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"seriesQuantity")," \\\nThe quantity of series constructor tokens to create.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt128"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: ",(0,l.kt)("inlineCode",{parentName:"li"},"mintingOutput.quantity")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"groupQuantity")," \\\nThe quantity of group constructor tokens to create.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: UInt128"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"),(0,l.kt)("li",{parentName:"ul"},"Default: ",(0,l.kt)("inlineCode",{parentName:"li"},"mintingOutput.quantity")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mintingOutput")," \\\nThe output containing the minted asset tokens",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#transactionoutput"},"TransactionOutput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"registrationOutputAccount")," \\\nThe Account for where the constructor tokens for policy registration will reside. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Account"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"groupLabel")," \\\nThe label for the new group policy.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: String"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: ",(0,l.kt)("inlineCode",{parentName:"li"},"assetAlias")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"seriesLabel")," \\\nThe label for the new series policy.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: String"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: ",(0,l.kt)("inlineCode",{parentName:"li"},"assetAlias")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fixSeriesToGroup")," \\\nA flag indicating if the created Group policy should only be allowed to be associated with the created series policy. If ",(0,l.kt)("inlineCode",{parentName:"li"},"true")," then any other created Series constructor tokens (not created in this call) will not be applicable with the created Group policy. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Boolean"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: false"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"supplyControlForSeries"),' \\\nDefines the expected on-chain behavior for how many Series may be "assigned" to a Group',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#mintingsupplypolicy"},"MintingSupplyPolicy")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mintConditionsForSeries")," \\\nDefines the proposition that must be stamped on a Group Constructor",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Proposition"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: signing proposition "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"onChainTransferBehaviors")," \\\nDefines the type of token within the TAM2 scheme",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#assetbehavior"},"AssetBehavior")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"supplyControlForAssets"),' \\\nDefines the expected on-chain behavior for how many Asset Tokens may be "produced" within a Series',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#mintingsupplypolicy"},"MintingSupplyPolicy")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mintConditionsForAssets")," \\\nDefines the proposition that must be stamped on a Series Constructor",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Proposition"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: signing proposition "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"seriesCommitScheme")," \\\nThis value defines the expected type of committment that users should employee when verifying data on asset tokens within the created series. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#commitType"},"CommitType")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"seriesMetadataScheme")," \\\nA (possibly mixin based) metadata definition that allows for application level data constructs. Possible schemes that this value could denote include HasUnit, HasDecimals, MimePointer, LookupKey, Labeled, Unstructured, Versionable, and more.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: TBD"),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"creationTime")," \\\nThe time that the application claims the transactions were created. This is translated to a UNIX timestamp and used to set the Schedule object's creation field.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: The current time"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"earliestTime")," \\\nThe earliest time that the transactions are eligible to be included in a block. This will be converted to a slot number and used to set the Schedule object's minimumSlot field. Note that this can be in the future. However, if it is too far in the future, then nodes may evict it from their mempool.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: Beginning of time "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"latestTime")," \\\nThe latest time that the transactions are eligible to be included in a block. This will be converted to a slot number and used to set the Schedule object's maximumSlot field.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: 5 minutes into the future"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"Returns")," \\\nResult",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = Array of ",(0,l.kt)("a",{parentName:"li",href:"#stagedfutures"},"StagedFutures")," for the submitted transactions"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"feeQuantity is not a multiple of 2"),(0,l.kt)("li",{parentName:"ul"},"Transaction is not valid"),(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller."))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"transaction")," \\\nSubmits a general purpose ",(0,l.kt)("a",{parentName:"p",href:"#transaction"},"Transaction"),"."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("em",{parentName:"p"},"Parameters")," "),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"fee")," \\\nThe inputs and change output relating to this transaction's fee."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: ",(0,l.kt)("a",{parentName:"li",href:"#transput"},"Transput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"data")," \\\nData to be associated with this transaction. Has no effect on the protocol level."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Byte","[15000]"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"inputs")," \\\nThe non-fee inputs and change outputs relating to this transaction."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Array of ",(0,l.kt)("a",{parentName:"li",href:"#transput"},"Transput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"outputs")," \\\nThe outputs of this transaction"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: Array of ",(0,l.kt)("a",{parentName:"li",href:"#transactionoutput"},"TransactionOutput")),(0,l.kt)("li",{parentName:"ul"},"Optional: no"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"creationTime")," \\\nThe time that the application claims the transaction was created. This is translated to a UNIX timestamp and used to set the Schedule object's creation field."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: The current time"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"earliestTime")," \\\nThe earliest time that this transaction is eligible to be included in a block. This will be converted to a slot number and used to set the Schedule object's minimumSlot field. Note that this can be in the future. However, if it is too far in the future, then nodes may evict it from their mempool."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: Beginning of time "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"latestTime")," \\\nThe latest time that this transaction is eligible to be included in a block. This will be converted to a slot number and used to set the Schedule object's maximumSlot field."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Type: DateTime | <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),">"),(0,l.kt)("li",{parentName:"ul"},"Optional: yes"),(0,l.kt)("li",{parentName:"ul"},"Default: 5 minutes into the future"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("em",{parentName:"p"},"Returns")," \\\nResult"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"S = ",(0,l.kt)("a",{parentName:"li",href:"#stagedfutures"},"StagedFutures")," for the submitted transaction"),(0,l.kt)("li",{parentName:"ul"},"F = <",(0,l.kt)("em",{parentName:"li"},"implementation defined"),"> This value should allow the caller to identify these error conditions:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Transaction is not valid"),(0,l.kt)("li",{parentName:"ul"},"An I/O, network, or database error that is unrelated to the parameters passed by the caller.")))))))),(0,l.kt)("h3",{id:"implementation-notes-24"},"Implementation Notes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"None")),(0,l.kt)("h1",{id:"notes-on-comments"},"Notes on Comments"),(0,l.kt)("p",null,"The markdown contains many lines commented out. These lines refer to topics that we will address at a later time. These topics include:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Off-chain data \\\nAnything related to the hosted URL or authentication of off-chain data")))}u.isMDXComponent=!0}}]);
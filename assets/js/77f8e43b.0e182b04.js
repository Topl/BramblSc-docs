"use strict";(self.webpackChunksdk_spec=self.webpackChunksdk_spec||[]).push([[8356],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},u=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(r),m=i,k=c["".concat(l,".").concat(m)]||c[m]||d[m]||a;return r?n.createElement(k,s(s({ref:t},u),{},{components:r})):n.createElement(k,s({ref:t},u))}));function m(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,s=new Array(a);s[0]=c;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var p=2;p<a;p++)s[p]=r[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}c.displayName="MDXCreateElement"},8362:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var n=r(7462),i=(r(7294),r(3905));const a={},s="Signing",o={unversionedId:"Modules/Crypto/Signing/Signing",id:"Modules/Crypto/Signing/Signing",title:"Signing",description:"The Signing submodule of crypto is responsible for signing data. Currently only one signing scheme is supported, which",source:"@site/docs/Modules/Crypto/Signing/Signing.md",sourceDirName:"Modules/Crypto/Signing",slug:"/Modules/Crypto/Signing/",permalink:"/sdk-spec/docs/Modules/Crypto/Signing/",draft:!1,editUrl:"https://github.com/topl/sdk-spec/tree/main/packages/create-docusaurus/templates/shared/docs/Modules/Crypto/Signing/Signing.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Blake2b512 Tests",permalink:"/sdk-spec/docs/Modules/Crypto/Hash/Hash Tests/Blake2b512Tests"},next:{title:"Native Transaction Builder",permalink:"/sdk-spec/docs/Modules/NativeTransactor/"}},l={},p=[{value:"Interface EllipticCurveSignatureScheme",id:"interface-ellipticcurvesignaturescheme",level:2},{value:"constant SignatureLength",id:"constant-signaturelength",level:3},{value:"Signature(s)",id:"signatures",level:4},{value:"Description",id:"description",level:4},{value:"constant KeyLength",id:"constant-keylength",level:3},{value:"Signature(s)",id:"signatures-1",level:4},{value:"Description",id:"description-1",level:4},{value:"method deriveKeyPairFromEntropy",id:"method-derivekeypairfromentropy",level:3},{value:"Signature(s)",id:"signatures-2",level:4},{value:"Description",id:"description-2",level:4},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Errors",id:"errors",level:4},{value:"method sign",id:"method-sign",level:3},{value:"Signature(s)",id:"signatures-3",level:4},{value:"Description",id:"description-3",level:4},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"Errors",id:"errors-1",level:4},{value:"method verify",id:"method-verify",level:3},{value:"Signature(s)",id:"signatures-4",level:4},{value:"Description",id:"description-4",level:4},{value:"Parameters",id:"parameters-2",level:4},{value:"Returns",id:"returns-2",level:4},{value:"Errors",id:"errors-2",level:4},{value:"method getVerificationKey",id:"method-getverificationkey",level:3},{value:"Signature(s)",id:"signatures-5",level:4},{value:"Description",id:"description-5",level:4},{value:"Parameters",id:"parameters-3",level:4},{value:"Returns",id:"returns-3",level:4},{value:"class Ed25519",id:"class-ed25519",level:2},{value:"<em>static</em> method instance",id:"static-method-instance",level:3},{value:"Signature(s)",id:"signatures-6",level:4},{value:"Description",id:"description-6",level:4},{value:"Parameters",id:"parameters-4",level:4},{value:"Returns",id:"returns-4",level:4},{value:"Errors",id:"errors-3",level:4},{value:"constant SignatureLength",id:"constant-signaturelength-1",level:3},{value:"Signature(s)",id:"signatures-7",level:4},{value:"Description",id:"description-7",level:4},{value:"constant KeyLength",id:"constant-keylength-1",level:3},{value:"Signature(s)",id:"signatures-8",level:4},{value:"Description",id:"description-8",level:4},{value:"method deriveKeyPairFromEntropy",id:"method-derivekeypairfromentropy-1",level:3},{value:"Signature(s)",id:"signatures-9",level:4},{value:"Description",id:"description-9",level:4},{value:"Parameters",id:"parameters-5",level:4},{value:"Returns",id:"returns-5",level:4},{value:"Errors",id:"errors-4",level:4},{value:"Testing Procedure",id:"testing-procedure",level:4},{value:"method sign",id:"method-sign-1",level:3},{value:"Signature(s)",id:"signatures-10",level:4},{value:"Description",id:"description-10",level:4},{value:"Parameters",id:"parameters-6",level:4},{value:"Returns",id:"returns-6",level:4},{value:"Errors",id:"errors-5",level:4},{value:"Testing Procedure",id:"testing-procedure-1",level:4},{value:"method verify",id:"method-verify-1",level:3},{value:"Signature(s)",id:"signatures-11",level:4},{value:"Description",id:"description-11",level:4},{value:"Parameters",id:"parameters-7",level:4},{value:"Returns",id:"returns-7",level:4},{value:"Errors",id:"errors-6",level:4},{value:"Testing Procedure",id:"testing-procedure-2",level:4},{value:"method getVerificationKey",id:"method-getverificationkey-1",level:3},{value:"Signature(s)",id:"signatures-12",level:4},{value:"Description",id:"description-12",level:4},{value:"Parameters",id:"parameters-8",level:4},{value:"Returns",id:"returns-8",level:4}],u={toc:p};function d(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"signing"},"Signing"),(0,i.kt)("p",null,"The Signing submodule of crypto is responsible for signing data. Currently only one signing scheme is supported, which\nis the Ed25519 scheme."),(0,i.kt)("h2",{id:"interface-ellipticcurvesignaturescheme"},"Interface EllipticCurveSignatureScheme"),(0,i.kt)("p",null,"Classes responsible for signing data using elliptic curve digital signatures implement this interface."),(0,i.kt)("h3",{id:"constant-signaturelength"},"constant SignatureLength"),(0,i.kt)("h4",{id:"signatures"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Int SignatureLength\n")),(0,i.kt)("h4",{id:"description"},"Description"),(0,i.kt)("p",null,"A constant whose value is the length of the signature in bytes."),(0,i.kt)("h3",{id:"constant-keylength"},"constant KeyLength"),(0,i.kt)("h4",{id:"signatures-1"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Int KeyLength\n")),(0,i.kt)("h4",{id:"description-1"},"Description"),(0,i.kt)("p",null,"A constant whose value is the length of the private signing keys in bytes."),(0,i.kt)("h3",{id:"method-derivekeypairfromentropy"},"method deriveKeyPairFromEntropy"),(0,i.kt)("h4",{id:"signatures-2"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"deriveKeyPairFromEntropy(entropy: Entropy, password: Option[String]) returns List[ByteVector]\n")),(0,i.kt)("h4",{id:"description-2"},"Description"),(0,i.kt)("p",null,"Derive a main key pair from an entropy value and a password. Note that this skips the step of creating a seed value and\nthen using that to generate the key pair."),(0,i.kt)("h4",{id:"parameters"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"entropy")," \u2014 The entropy value to use to derive the key pair."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"password")," \u2014 The password to use to derive the key pair. The default is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),".")),(0,i.kt)("h4",{id:"returns"},"Returns"),(0,i.kt)("p",null,"A list of two ",(0,i.kt)("a",{parentName:"p",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," objects. The first is the private\nsigning key and the second is the public verification key."),(0,i.kt)("h4",{id:"errors"},"Errors"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},(0,i.kt)("em",{parentName:"em"},"None"))),(0,i.kt)("h3",{id:"method-sign"},"method sign"),(0,i.kt)("h4",{id:"signatures-3"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"sign(privateKey: ByteVector, message: ByteVector) returns ByteVector\n")),(0,i.kt)("h4",{id:"description-3"},"Description"),(0,i.kt)("p",null,"Create a signature for a message using a private signing key."),(0,i.kt)("h4",{id:"parameters-1"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"privateKey")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the private signing\nkey to use to sign the message."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"message")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the message to sign.")),(0,i.kt)("h4",{id:"returns-1"},"Returns"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the signature."),(0,i.kt)("h4",{id:"errors-1"},"Errors"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},(0,i.kt)("em",{parentName:"em"},"None"))),(0,i.kt)("h3",{id:"method-verify"},"method verify"),(0,i.kt)("h4",{id:"signatures-4"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"verify(signature: ByteVector, message:ByteVector, verificationKey: ByteVector) returns Boolean\n")),(0,i.kt)("h4",{id:"description-4"},"Description"),(0,i.kt)("p",null,"Verify that a signature is valid for a message using a public verification key."),(0,i.kt)("h4",{id:"parameters-2"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"signature")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the signature to\nverify."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"message")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the message that was\nsigned."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"verificationKey")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the public\nverification key to use to verify the signature.")),(0,i.kt)("h4",{id:"returns-2"},"Returns"),(0,i.kt)("p",null,"True if the signature is valid, false otherwise."),(0,i.kt)("h4",{id:"errors-2"},"Errors"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},(0,i.kt)("em",{parentName:"em"},"None"))),(0,i.kt)("h3",{id:"method-getverificationkey"},"method getVerificationKey"),(0,i.kt)("h4",{id:"signatures-5"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"getVerificationKey(privateKey: ByteVector) returns ByteVector\n")),(0,i.kt)("h4",{id:"description-5"},"Description"),(0,i.kt)("p",null,"Derive a public verification key from a private signing key."),(0,i.kt)("h4",{id:"parameters-3"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"privateKey")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the private signing\nkey to use to derive the public verification key.")),(0,i.kt)("h4",{id:"returns-3"},"Returns"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the derived public verification key."),(0,i.kt)("h2",{id:"class-ed25519"},"class Ed25519"),(0,i.kt)("p",null,"This class implements the Ed25519 elliptic curve digital signature scheme as described\nin ",(0,i.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc8032"},"RFC 8032"),"."),(0,i.kt)("p",null,"This class should be implemented as a wrapper for an external library that implements the Ed25519 signing scheme."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Implements")," ",(0,i.kt)("a",{parentName:"p",href:"#interface-ellipticcurvesignaturescheme"},"EllipticCurveSignatureScheme")),(0,i.kt)("h3",{id:"static-method-instance"},(0,i.kt)("em",{parentName:"h3"},"static")," method instance"),(0,i.kt)("h4",{id:"signatures-6"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"static instance() returns Ed25519\n")),(0,i.kt)("h4",{id:"description-6"},"Description"),(0,i.kt)("p",null,"Return the singleton instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Ed25519"),"."),(0,i.kt)("h4",{id:"parameters-4"},"Parameters"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},(0,i.kt)("em",{parentName:"em"},"None"))),(0,i.kt)("h4",{id:"returns-4"},"Returns"),(0,i.kt)("p",null,"Return the singleton instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Ed25519"),"."),(0,i.kt)("h4",{id:"errors-3"},"Errors"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},(0,i.kt)("em",{parentName:"em"},"None"))),(0,i.kt)("h3",{id:"constant-signaturelength-1"},"constant SignatureLength"),(0,i.kt)("h4",{id:"signatures-7"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Int SignatureLength\n")),(0,i.kt)("h4",{id:"description-7"},"Description"),(0,i.kt)("p",null,"A constant whose value is the length of the signature in bytes."),(0,i.kt)("h3",{id:"constant-keylength-1"},"constant KeyLength"),(0,i.kt)("h4",{id:"signatures-8"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Int KeyLength\n")),(0,i.kt)("h4",{id:"description-8"},"Description"),(0,i.kt)("p",null,"A constant whose value is the length of the private signing keys in bytes."),(0,i.kt)("h3",{id:"method-derivekeypairfromentropy-1"},"method deriveKeyPairFromEntropy"),(0,i.kt)("h4",{id:"signatures-9"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"deriveKeyPairFromEntropy(entropy: Entropy, password: Option[String]) returns List[ByteVector]\n")),(0,i.kt)("h4",{id:"description-9"},"Description"),(0,i.kt)("p",null,"Derive a main key pair from an entropy value and a password."),(0,i.kt)("h4",{id:"parameters-5"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"entropy")," \u2014 The entropy value to use to derive the key pair."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"password")," \u2014 The password to use to derive the key pair. The default is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),".")),(0,i.kt)("h4",{id:"returns-5"},"Returns"),(0,i.kt)("p",null,"A list of two ",(0,i.kt)("a",{parentName:"p",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," objects. The first is the private\nsigning key and the second is the public verification key."),(0,i.kt)("h4",{id:"errors-4"},"Errors"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},(0,i.kt)("em",{parentName:"em"},"None"))),(0,i.kt)("h4",{id:"testing-procedure"},"Testing Procedure"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Given")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"entropy1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"entropy2")," are two arbitrary entropy values"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"And")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"msg1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"msg2")," are two arbitrary  ",(0,i.kt)("a",{parentName:"p",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},"byte vectors")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"When")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ed25519 = new Ed25519()\nkeyPair1 = ed25519.deriveKeyPairFromEntropy(entropy1, None)\nkeyPair2 = ed25519.deriveKeyPairFromEntropy(entropy2, None)\nsig = ed25519.sign(keyPair1[0], msg1)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Then")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ed25519.verify(sig, msg1, keyPair1[0])")," should return ",(0,i.kt)("inlineCode",{parentName:"p"},"true")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ed25519.verify(sig, msg1, keyPair2[0])")," should return ",(0,i.kt)("inlineCode",{parentName:"p"},"false")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ed25519.verify(sig, msg2, keyPair1[0])")," should return ",(0,i.kt)("inlineCode",{parentName:"p"},"false")),(0,i.kt)("h3",{id:"method-sign-1"},"method sign"),(0,i.kt)("h4",{id:"signatures-10"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"sign(privateKey: ByteVector, message: ByteVector) returns ByteVector\n")),(0,i.kt)("h4",{id:"description-10"},"Description"),(0,i.kt)("p",null,"Sign a message using a private signing key."),(0,i.kt)("h4",{id:"parameters-6"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"privateKey")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the private signing\nkey to use to sign the message."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"message")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the message to sign.")),(0,i.kt)("h4",{id:"returns-6"},"Returns"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the signature."),(0,i.kt)("h4",{id:"errors-5"},"Errors"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},(0,i.kt)("em",{parentName:"em"},"None"))),(0,i.kt)("h4",{id:"testing-procedure-1"},"Testing Procedure"),(0,i.kt)("p",null,"The test vectors in ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc8032#section-7.1"},"https://datatracker.ietf.org/doc/html/rfc8032#section-7.1")," specify values for ",(0,i.kt)("inlineCode",{parentName:"p"},"secretKey"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"message"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"signature"),". The test should verify that the signature returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"sign")," matches the expected signature for each\nvalue of ",(0,i.kt)("inlineCode",{parentName:"p"},"secretKey")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"message"),"."),(0,i.kt)("h3",{id:"method-verify-1"},"method verify"),(0,i.kt)("h4",{id:"signatures-11"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"verify(signature: ByteVector, message:ByteVector, verificationKey: ByteVector) returns Boolean\n")),(0,i.kt)("h4",{id:"description-11"},"Description"),(0,i.kt)("p",null,"Verify that a signature is valid for a message using a public verification key."),(0,i.kt)("h4",{id:"parameters-7"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"signature")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the signature to\nverify."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"message")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the message that was\nsigned."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"verificationKey")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the public\nverification key to use to verify the signature.")),(0,i.kt)("h4",{id:"returns-7"},"Returns"),(0,i.kt)("p",null,"True if the signature is valid, false otherwise."),(0,i.kt)("h4",{id:"errors-6"},"Errors"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},(0,i.kt)("em",{parentName:"em"},"None"))),(0,i.kt)("h4",{id:"testing-procedure-2"},"Testing Procedure"),(0,i.kt)("p",null,"The test vectors in ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc8032#section-7.1"},"https://datatracker.ietf.org/doc/html/rfc8032#section-7.1")," specify values for ",(0,i.kt)("inlineCode",{parentName:"p"},"publicKey"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"message"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"signature"),". The test should verify that the ",(0,i.kt)("inlineCode",{parentName:"p"},"verify")," function returns true for the combinations of these values in\nthe test vectors. The test should also include some combinations of the values from different test vectors for which it\nshould return false."),(0,i.kt)("h3",{id:"method-getverificationkey-1"},"method getVerificationKey"),(0,i.kt)("h4",{id:"signatures-12"},"Signature(s)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"getVerificationKey(privateKey: ByteVector) returns ByteVector\n")),(0,i.kt)("h4",{id:"description-12"},"Description"),(0,i.kt)("p",null,"Get the public verification key corresponding to a private signing key."),(0,i.kt)("h4",{id:"parameters-8"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"privateKey")," \u2014 A ",(0,i.kt)("a",{parentName:"li",href:"/docs/Modules/Common/External%20Libraries/ByteVector"},(0,i.kt)("inlineCode",{parentName:"a"},"ByteVector"))," containing the private signing\nkey to use to derive the public verification key.")),(0,i.kt)("h4",{id:"returns-8"},"Returns"),(0,i.kt)("p",null,"The verification key corresponding to the given private signing key."))}d.isMDXComponent=!0}}]);